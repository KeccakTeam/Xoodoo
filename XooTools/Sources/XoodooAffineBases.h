/*
XooTools, a set of C++ classes for analyzing Xoodoo.

Xoodoo, designed by Joan Daemen, Seth Hoffert, Gilles Van Assche and Ronny Van Keer.
For specifications, please refer to https://eprint.iacr.org/2018/767
For contact information, please visit https://keccak.team/team.html

Implementation by Gilles Van Assche, hereby denoted as "the implementer".

To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
*/

#ifndef _XOODOOAFFINEBASES_H_
#define _XOODOOAFFINEBASES_H_

#include <cstdint>
#include <string>
#include "XoodooDCLC.h"

using namespace std;

/** Like ListOfColumnPatterns, this class lists the row patterns (differences or linear masks)
  * for a given row input pattern, but in the form of an affine space.
  * The members of the list are determined by offset plus any linear combination
  * of the generators.
  */
class AffineSpaceOfColumns {
public:
    /** The generators. */
    vector<ColumnValue> generators;
    /** The offset. */
    ColumnValue offset;
public:
    /** The constructor creates an affine space with a single element: 0. */
    AffineSpaceOfColumns() { offset = 0; }
    /** This method adds a generator to the set of generators.
      * @param   generator  The generator to add
      */
    void addGenerator(ColumnValue generator) { generators.push_back(generator); }
    /** This method sets the offset of the affine space.
      * @param   anOffset   The new offset value.
      */
    void setOffset(ColumnValue anOffset) { offset = anOffset; }
    /** This method displays the offset and generators.
      * @param   fout       The stream to display to.
      */
    void display(ostream& fout) const;
    /**
      * This method returns the number of generators.
      * After they are set, the number of generators happens to be equal
      * to the propagation weight of the input pattern
      * whose output space is represented by this affine space.
      * @return    The number of generators (propagation weight).
      */
    unsigned int getWeight() const { return generators.size(); }
    /**
      * This method returns in the given vector the list of all possible column values.
      */
    void getAllColumnValues(vector<ColumnValue>& list) const;
};

/** This class implements an iterator over the affine space generated by the given
  * base and offset.
  */
template<class State>
class AffineSpaceIterator {
private:
    vector<State> *emptyBase;
    const vector<State> *base;
    State current;
    uint64_t begin, i, end;
public:
    /** This constructor creates an empty iterator. */
    AffineSpaceIterator(const State& zero)
        : emptyBase(new vector<State>), base(emptyBase), current(zero), begin(0), i(0), end(0) {}
    /** This constructor initializes the affine space iterator with a given generator base
      * and a given offset.
      * @param   aBase      The generator base, as a reference to the set (vector) of generators.
      *                     Each generator is a vector of elements of template type @a T.
      * @param   aOffset    The offset, as a reference to a vector of elements of template type @a T.
      */
    AffineSpaceIterator(const vector<State>& aBase, const State& aOffset)
        : emptyBase(0), base(&aBase), current(aOffset), begin(0), i(0), end((uint64_t)1<<base->size())
    {
    }
    void fastForward(uint64_t target)
    {
        uint64_t sourceVectors = i ^ (i >> 1);
        uint64_t targetVectors = target ^ (target >> 1);
        uint64_t changeVectors = sourceVectors ^ targetVectors;

        for(unsigned int index=0; index<base->size(); index++) {
            if ((changeVectors & ((uint64_t)1<<index)) != 0)
                current ^= (*base)[index];
        }
        i = target;
    }
    AffineSpaceIterator(const vector<State>& aBase, const State& aOffset, uint64_t aBegin, uint64_t aEnd)
        : emptyBase(0), base(&aBase), current(aOffset), begin(aBegin), i(0), end(aEnd)
    {
        fastForward(aBegin);
    }
    /** The destructor. */
    ~AffineSpaceIterator()
    {
        if (emptyBase)
            delete emptyBase;
    }
    /** This method tells whether the last element of the affine space
      * has been reached.
      * @return True iff the last element of the affine space has been reached.
      */
    bool isEnd() const
    {
        return i >= end;
    }
    /** This method moves the iterator to the next element in the affine space. */
    void operator++()
    {
        if (i < (end-1)) {
            unsigned int index = 0;
            while((i & ((uint64_t)1<<index)) != 0)
                index++;
            current ^= (*base)[index];
        }
        i++;
    }
    /** This method returns a constant reference to the current element in the affine space.
      * @return The current element in the affine space.
      */
    const State& operator*() const
    {
        return current;
    }
    /** This method displays the offset and generators.
      * @param   fout       The stream to display to.
      */
    void display(ostream& fout) const
    {
        fout << "Offset:" << endl;
        fout << current << endl;

        for(unsigned int i=0; i<base->size(); i++) {
            fout << "Base  element #" << dec << i << ":" << endl;
            fout << (*base)[i] << endl;
        }
    }
    /** This method returns the number of elements in the affine space.
      * @return The number of elements in the affine space.
      */
    uint64_t getCount() const
    {
        return end-begin;
    }
    uint64_t getCurrent() const
    {
        return i;
    }
};

typedef AffineSpaceIterator<XoodooState> XoodooAffineSpaceIterator;

/** This class expresses an affine space of states.
  * The members of the affine space are determined by the offset
  * plus any linear combination of the generators.
  * The generators are split into two sets:
  * - one set of generators that have a zero parity (called "parity-kernel"), and
  * - one set of generators that have a non-zero parity (called "parity-offset").
  * This allows one to address a subspace of states with a given parity.
  */
class AffineSpaceOfStates {
protected:
    const XoodooDCLC& instance;
public:
    /** The set of generators, before separation into parity-kernel and
      * parity-offset sets.
      */
    vector<XoodooState> originalGenerators;
    /** The set of parities, before separation into parity-kernel and
      * parity-offset sets, i.e., originalParities[i] contains the parity
      * of originalGenerators[i].
      */
    vector<XoodooPlane> originalParities;
    /** The set of parity-kernel generators of the affine space.
      */
    vector<XoodooState> kernelGenerators;
    /** The set of parity-offset generators of the affine space.
      * This can be used to generate an offset for a given parity.
      * The parity-offset generators are organized such that their parity
      * makes an upper-triangular matrix. In other words, whenever
      * a generator has parity bit <i>n</i> set to 1
      * and parity bits <i>m</i>&lt;<i>n</i> set to 0,
      * the next generators necessarily have parity bits <i>m</i>&lt;=<i>n</i> set to 0.
      */
    vector<XoodooState> offsetGenerators;
    /** This vector contains the parities of offsetGenerators, i.e.,
      * offsetParities[i] contains the parity of offsetGenerators[i].
      */
    vector<XoodooPlane> offsetParities;
    /** The offset of the affine space.
      */
    XoodooState offset;
    /** The parity of the offset of the affine space.
      */
    XoodooPlane offsetParity;
public:
    /** This constructor initializes the different attributes from the given generators,
      * the offset and their parities.
      * @note The passed vectors aGenerators and aGeneratorParities are modified in the process.
      * @param   anInstance         The Xoodoo instance.
      * @param   aGenerators        The set of generators of the affine space.
      * @param   aGeneratorParities The associated parities.
      * @param   aOffset            The offset of the affine space.
      * @param   aOffsetParity      The parity associated to the offset.
      */
    AffineSpaceOfStates(const XoodooDCLC& anInstance, vector<XoodooState>& aGenerators, vector<XoodooPlane>& aGeneratorParities, const XoodooState& aOffset, const XoodooPlane& aOffsetParity);
    /** This method returns a state value (in argument @a output) with a given parity.
      * From the offset and the parity-offset generators of the affine space, this method
      * computes an element that has the given parity. (Note that other elements with the same parity
      * can be generated by adding any linear combination of parity-kernel generators.)
      * If the given parity cannot be reached, false is returned.
      * @param   parity     The requested parity.
      * @param   output     The state returned by the method with the requested parity, if possible.
      * @return The method returns true iff a state can be found in the affine space with the requested parity.
      */
    bool getOffsetWithGivenParity(const XoodooPlane& parity, XoodooState& output) const;
    /** This method returns an iterator to all states in the affine space.
      * @return The iterator to the whole affine space.
      */
    XoodooAffineSpaceIterator getIterator() const;
    /** This method returns an iterator to the affine space restricted to a given parity.
      * In the returned iterator, its offset is computed as in method getOffsetWithGivenParity()
      * and its generators are the parity-kernel generators.
      * @param   parity     The requested parity.
      * @return An iterator to all states in the affine space, restricted to the requested parity.
      */
    XoodooAffineSpaceIterator getIteratorWithGivenParity(const XoodooPlane& parity) const;
    /** Like getIteratorWithGivenParity() with the requested parity being zero.
      * @return An iterator to all states in the affine space with zero parity (i.e., in the kernel).
      */
    XoodooAffineSpaceIterator getIteratorInKernel() const;
    /** This method displays the offset and generators.
      * @param   fout       The stream to display to.
      */
    void display(ostream& fout) const;
private:
    void setGenerators(vector<XoodooState>& aGenerators, vector<XoodooPlane>& aGeneratorParities);
};

#endif
